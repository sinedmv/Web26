# ЛР 6. Применение возможностей NestJS для разработки BFF

В данной лабораторной работе необходимо изучить различные механизмы работы с запросами, которые предоставляет NestJS. Часть таких механизмов была изучена в прошлых лабораторных работах (например, exception filters и validation pipes), часть будет в следующей (декораторы), часть нужно будет посмотреть тут :)

## Измерение времени обработки запроса

Напишите свой [перехватчик (interceptor)](https://docs.nestjs.com/interceptors), который будет измерять время обработки запроса. Здесь, как и в случае с SSE, применяются концепции реактивного программирования, поэтому в том числе стоит ещё раз пройтись по тому, что это такое и зачем нужна [библиотека RxJS](https://www.learnrxjs.io/).

Перехватчик должен не только вывести в логи затраченное время, но и вернуть его клиенту. Если запрос рендерит страницу, то затраченное на сервере время должно отобразиться рядом с временем, затраченным на клиенте, для этого перехватчик должен вернуть время в шаблонизатор. Если запрос является вызовом RESTful API или GraphQL, то затраченное время нужно вернуть в HTTP-заголовке ответа, например, `X-Elapsed-Time`.

## Кэширование ответов

Реализуйте кэширование ответов RESTful API как на клиенте, так и на сервере.

Кэширование на клиенте предлагается реализовать с помощью комбинации двух механизмов, [Entity Tag (ETag)](https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Headers/ETag) и заголовка `Cache-Control`. Такой подход полезен тем, что позволяет не только закэшировать ресурс на определённое время (например, на час) и в течение этого времени не запрашивать его повторно, но и не запрашивать полную версию ресурса, если в течение часа он не менялся. Заголовок `Cache-Control` можно поставить на нужные эндпоинты с помощью соответствующего декоратора, а генерацию ETag предлагается реализовать с помощью ещё одного перехватчика.

Кэширование на сервере нужно реализовать in-memory с помощью [стандартного модуля CacheModule](https://docs.nestjs.com/techniques/caching) и только для одной сущности (попробуйте подумать, к чему будут чаще всего обращаться). Чтобы сильно не заморачиваться с обновлением кэша при обновлении сущностей, предлагается настроить Time-To-Live порядка нескольких секунд и проверить работоспособность кэша с помощью отправки некоторого количества запросов подряд (например, с помощью утилиты [`hey`](https://github.com/rakyll/hey)). При желании можно реализовать честное кэширование с ручным обновлением, это будет эффективнее, но чуть дольше по времени.

## Загрузка файлов в объектное хранилище

У некоторых из вас уже есть функциональность, завязанная на файлах (загрузка фотографий, например). Вместо того, чтобы указывать ссылку на файл самостоятельно, нужно научиться загружать эти файлы в объектное (S3-совместимое) хранилище. Предлагается воспользоваться [Yandex Object Storage](https://yandex.cloud/ru/docs/storage/), так как оно предоставляет 1 ГБ бесплатно. Создайте бакет через интерфейс Яндекс.Облака и подключите бакет к приложению с использованием [AWS SDK для JavaScript](https://yandex.cloud/ru/docs/storage/tools/aws-sdk-js). Для загрузки файлов рекомендуется написать отдельный инфраструктурный модуль (по аналогии с Prisma ORM) и подключать его там, где он требуется. Чтобы получить файлы при загрузке на стороне бэкенда, нужно почитать соответствующий [раздел документации NestJS](https://docs.nestjs.com/techniques/file-upload). Опционально настройте валидацию файлов по их размеру и типу по той же документации.

Если работы с файлами до этого не было, нужно её добавить и выполнить пункты выше :)
